
import { time } from "@nomicfoundation/hardhat-network-helpers"
import { expect } from "chai";
import { Block, ContractFactory } from "ethers";
import { ethers } from "ethers";
import hre from "hardhat";
import * as Custom from "./types"
import * as Utils from "./utils"
import * as JsSolidity from "./solidity"

// importing types generated by typechain
import { AssetManager, 
         AssetManager__factory, 
         AssetManagerWrapper, 
         AssetManagerWrapper__factory, 
         LBMainV1, 
         LBMainV1__factory, 
         LBToken,     
         LBToken__factory, PriceOracle, 
         PriceOracle__factory } from "../typechain-types";
import { Types as AMTypes } from "../typechain-types/contracts/AssetManager.v1.sol/AssetManager";
import { Types as LMTypes } from "../typechain-types/contracts/abstracts/LoanManager";

describe("LBMain.v1", function () {
    // Signers
    let owner:         Custom.HardhatSigner,  supplier:        Custom.HardhatSigner, 
     assetManagerUser: Custom.HardhatSigner,  protocolManager: Custom.HardhatSigner,
     borrower:         Custom.HardhatSigner;

     // Factories
    let 
    _lbToken:              LBToken__factory,    _mainLbV1:       LBMainV1__factory, 
    _asset:                AssetManager__factory, 
    _wrapperAssetManager:  AssetManagerWrapper__factory,
    _borrowableAsset:      LBToken__factory,  _priceOracle: PriceOracle__factory;

    // Contracts
    let 
    $lbToken:              LBToken,               $mainLb:               LBMainV1, 
    $assetManager:         AssetManager,          $lbtOfLendingToken:    LBToken,            
    $wrapperAssetManager:  AssetManagerWrapper,   $borrowableAsset:      LBToken,
    $collaterallableAsset: LBToken,               $lbtOfBorrowableToken: LBToken,
    $priceOracle: PriceOracle;

    this.beforeEach(async function(){
        [owner, supplier, borrower, assetManagerUser, protocolManager] = await hre.ethers.getSigners();

        // Creating contract factories
        _asset               = await hre.ethers.getContractFactory("AssetManager");
        _wrapperAssetManager = await hre.ethers.getContractFactory("AssetManagerWrapper");
        _mainLbV1            = await hre.ethers.getContractFactory("LBMainV1");
        _lbToken             = await hre.ethers.getContractFactory("LBToken");
        _borrowableAsset     = await hre.ethers.getContractFactory("LBToken");
        _priceOracle         = await hre.ethers.getContractFactory("PriceOracle");


        // deloying the instanciated contracts
        $mainLb                = await _mainLbV1.connect(owner).deploy();
        $assetManager          = await _asset.connect(assetManagerUser).deploy(await $mainLb.getAddress());
        $wrapperAssetManager   = await _wrapperAssetManager.connect(assetManagerUser).deploy(await $assetManager.getAddress());
        $lbToken               = await _lbToken.connect(owner)   .deploy(ethers.parseEther("1000"), "MOCK",                 "MTK");
        $borrowableAsset       = await _lbToken.connect(supplier).deploy(ethers.parseEther("1000"), "LoanToken",            "LTK");
        $collaterallableAsset  = await _lbToken.connect(borrower).deploy(ethers.parseEther("1000"),    "CollateralAsset",      "CLAS");
        $lbtOfBorrowableToken  = await _lbToken.connect(owner)   .deploy(0n,      "LBTOfBorrowable",      "LBTBorr");
        $lbtOfLendingToken     = await _lbToken.connect(owner)   .deploy(0n,      "LBTOfCollateralAsset", "LBTColl");
        $priceOracle           = await _priceOracle.connect(owner)   .deploy();

        // change ownership of LBToken contracts to mainLb contract
        // @todo on contract side, when LBToken roles are defined, it would be more appropriate
        // to add them here too. Instead of changing ownership, which is not a good approach
        console.log(await owner.getAddress());
        console.log(await $mainLb.getAddress());
        
        let tx = await $lbtOfBorrowableToken.connect(owner).changeOwner(await $mainLb.getAddress(), 0n);
        await tx.wait()
        tx = await $lbtOfLendingToken.connect(owner).changeOwner(await $mainLb.getAddress(), 0n);
        await tx.wait()

       

        // doing basic and necessary contracts authorization and delegations
        tx = await $assetManager.addUser(await $wrapperAssetManager.getAddress(), 0x0011);
        await tx.wait();

         // we add mainLb contract as both price reader and writer
        tx = await $priceOracle.connect(owner).addUser(await $mainLb.getAddress(), 0x0041)
        tx = await $priceOracle.connect(owner).addUser(protocolManager, 0x0041)
        await tx.wait();
        expect(Custom.hexPrint(await $priceOracle.connect(owner).userGetRole(await $mainLb.getAddress()))).to.equal("0x0041")
        tx = await $mainLb.connect(owner).setPriceOracleContract(await $priceOracle.getAddress());
        await tx.wait();
    });

    // Definition: two assets are deposited, which
    // are named $collateralAsset and $borrowableAsset.
    // The lender user lends $borrowableAsset asset to the system;
    // then the borrower user lends $collateral asset to the system, too.
    // A system user updates the PriceOracle with a proper ratio
    // between the above assets. Making them exchangeable, technically.
    // The borrower user requests to borrow from $borrowableAsset,
    // given that it already has enoguh collateral. These are all
    // asserted continously within the test suit. 
    // During each major operation, subtle things such as
    // roles, users, index etc. are asserted
    it("a complete lend and borrow cycle", async function() {    
        let lentAsset: AMTypes.AssetStruct = {
            asset:                   await $collaterallableAsset.getAddress(),
            wrapperToken:            await $lbtOfLendingToken.getAddress(),
            allowAsCollateral:       true,
            active:                  true,
            rslopeAfterUT:           Custom.getPercentOf(Custom.Ray, 15n),
            rslopeBeforeUT:          Custom.getPercentOf(Custom.Ray, 60n),
            liquidityRate:           0n,
            borrowRate:              0n,
            ltv:                     75n,
            protocolShareMultiplier: 0n,
            liquidityIndex:          Custom.Ray,
            borrowIndex:             1n,
            changedBy:               ethers.ZeroAddress,
            indexChangedAt:          0n,
            changedAt:               0n,
            scaledBalance:           0n,
            minBorrowAmount:         0n,
            borrowable:              true,
            stableBorrows:           0n,
            totalLoansCount:         0n,
            currentLtv:              0n
        };

        let borrowableAsset: AMTypes.AssetStruct = {
            asset:                   await $borrowableAsset.getAddress(),
            wrapperToken:            await $lbtOfBorrowableToken.getAddress(),
            allowAsCollateral:       true,
            active:                  true,
            rslopeAfterUT:           Custom.getPercentOf(Custom.Ray, 15n),
            rslopeBeforeUT:          Custom.getPercentOf(Custom.Ray, 60n),
            liquidityRate:           0n,
            borrowRate:              0n,
            ltv:                     75n,
            protocolShareMultiplier: 0n,
            liquidityIndex:          Custom.Ray,
            borrowIndex:             1n,
            changedBy:               ethers.ZeroAddress,
            indexChangedAt:          0n,
            changedAt:               0n,
            scaledBalance:           0n,
            minBorrowAmount:         0n,
            borrowable:              true,
            stableBorrows:           0n,
            totalLoansCount:         0n,
            currentLtv:              0n
        };

        // setting arbitrary price ratios on priceOracle contract
        await $priceOracle.connect(protocolManager).setRatio(await $collaterallableAsset.getAddress(), await $borrowableAsset.getAddress(), ethers.parseUnits("0.8", 18));
        await $priceOracle.connect(protocolManager).setRatio(await $borrowableAsset.getAddress(), await $collaterallableAsset.getAddress(), ethers.parseUnits("1.2", 18));

        // now let's assert pricing
        let priceRatio = await $priceOracle.connect(protocolManager).getRatio(await $borrowableAsset.getAddress(), await $collaterallableAsset.getAddress()); 
        console.log(priceRatio);

        // handling authorizations and user delegation
        await $mainLb.connect(owner).addUser(owner, 0xFFFD);
        await $mainLb.connect(owner).addUser(protocolManager, 0x0041);
        
        expect(Custom.hexPrint(await $mainLb.connect(owner).userGetRole(await protocolManager.getAddress()))).to.equal("0x0041")

        await       $mainLb.connect(protocolManager) .setContractActivation(true);              
        await       $mainLb.connect(owner)           .addUser(await $assetManager.getAddress(), 0x0011);
        await $assetManager.connect(assetManagerUser).addUser(assetManagerUser, 0x0011);
        await $assetManager.connect(assetManagerUser).setAsset(lentAsset,     await assetManagerUser.getAddress());
        await $assetManager.connect(assetManagerUser).setAsset(borrowableAsset, await assetManagerUser.getAddress());

        // financing
         await $borrowableAsset.connect(supplier).approve($mainLb.getAddress(), ethers.parseUnits("2", 18))
        let tx            = await $mainLb.connect(supplier).lend(await $borrowableAsset.getAddress(), ethers.parseUnits("1", 18));
        let receipt       = await tx.wait();
        let debugEvent    = Utils.GetEvent($mainLb, receipt, "LiquidityInterestIndexUpdate");
        let LIndex        = await $wrapperAssetManager.connect(assetManagerUser).getLiquidityIndex(await $borrowableAsset.getAddress())
        let scaledBalance = await $wrapperAssetManager.connect(assetManagerUser).getScaledBalance(await $borrowableAsset.getAddress())
        // assertions
        expect(scaledBalance).to.equal(JsSolidity.getScaledBalance(ethers.parseUnits("1", 18), LIndex));
        
        // forwarding the blocks
        let currentBlock: Block | null = await hre.ethers.provider.getBlock(await hre.ethers.provider.getBlockNumber());
        if(currentBlock != null) {
            // since there is no borrowing yet, the following
            // block forwarding must NOT in any way affect
            // interest index, as it remains 1 due to utilization of 0
            await time.increaseTo(currentBlock?.timestamp+100000);
        }
        
        // doing more transactions
        tx            = await $mainLb.connect(supplier).lend(await $borrowableAsset.getAddress(), ethers.parseUnits("1", 18));
        receipt       = await tx.wait();
        debugEvent = Utils.GetEvent($mainLb, receipt, "SupplyAdded");
        console.log(debugEvent.args);
        debugEvent    = Utils.GetEvent($mainLb, receipt, "LiquidityInterestIndexUpdate");
        scaledBalance = await $wrapperAssetManager.connect(assetManagerUser).getScaledBalance(await $borrowableAsset.getAddress());
        LIndex        = await $wrapperAssetManager.connect(assetManagerUser).getLiquidityIndex(await $borrowableAsset.getAddress())
        // doing the assertions
        expect(scaledBalance).to.equal(JsSolidity.getScaledBalance(ethers.parseUnits("2", 18), LIndex));
        
        // the following line, though calls lend(), but is meant for further collateralization
        await $collaterallableAsset.connect(borrower).approve($mainLb.getAddress(), ethers.parseUnits("2", 18));
        tx  = await $mainLb.connect(borrower).lend(await $collaterallableAsset.getAddress(), ethers.parseUnits("2", 18));
        receipt = await tx.wait();
        
        debugEvent = Utils.GetEvent($mainLb, receipt, "SupplyAdded");
        console.log(debugEvent.args);
        // asserting expectations
        expect(await $mainLb.connect(borrower).getUserBalance(await borrower.getAddress(), 
               await $collaterallableAsset.getAddress())).to.equal(ethers.parseUnits("2", 18));
        expect(await $mainLb.connect(supplier).getUserBalance(await supplier.getAddress(), 
               await $borrowableAsset.getAddress()))     .to.equal(ethers.parseUnits("2", 18));
        expect(await $borrowableAsset.balanceOf(await $mainLb.getAddress()))
                                                          .to.equal(ethers.parseUnits("2", 18)); 
        // now we do a borrowing
        tx  = await $mainLb.connect(borrower).borrow(await $borrowableAsset.getAddress(), 
                            await $collaterallableAsset.getAddress(), ethers.parseUnits("1.0", 18));
        await tx.wait();

        let userLoan: LMTypes.LoanStructOutput = await $mainLb.connect(borrower).getUserLoan(await $borrowableAsset.getAddress());

        currentBlock = await hre.ethers.provider.getBlock(await hre.ethers.provider.getBlockNumber());
        expect(userLoan.amount).to.equal(ethers.parseUnits("1.0", 18));
        expect(userLoan.loanedAt).to.equal(currentBlock?.timestamp);
    });
});